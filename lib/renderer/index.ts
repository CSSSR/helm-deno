import * as yaml from "https://deno.land/std@0.70.0/encoding/yaml.ts"
import * as fs from "https://deno.land/std@0.70.0/fs/mod.ts"
import * as path from "https://deno.land/std@0.70.0/path/mod.ts"
import { checkChartPath } from "../common/helm.ts"
import { Manifest, stringifyResource } from "../common/k8s.ts"

interface HelmRelease {
  Name: string
  Namespace: string
  IsInstall: string
  IsUpgrade: string
  Revision: number
  Service: string
}

function normalizeRelease(r: HelmRelease) {
  return {
    name: r.Name,
    namespace: r.Namespace,
    isInstall: r.IsInstall,
    isUpgrade: r.IsUpgrade,
    revision: r.Revision,
    service: r.Service,
  }
}

function parseKubertaData(spec: Record<string, unknown>) {
  const { release, values, jsTemplate } = spec

  if (typeof release !== "string") {
    throw new Error("Invalid kuberta data: release is not a string")
  }

  if (typeof values !== "string") {
    throw new Error("Invalid kuberta data: values is not a string")
  }

  if (typeof jsTemplate !== "string") {
    throw new Error("Invalid kuberta data: jsTemplate is not a string")
  }

  return {
    release: normalizeRelease(yaml.parse(release) as HelmRelease),
    values: yaml.parse(values),
    jsTemplate,
  }
}

function getTemplateName(manifest: Manifest): string {
  const name = manifest?.metadata?.name
  const namespace = manifest?.metadata?.namespace
  const kind = manifest?.kind?.toLowerCase()

  if ([name, kind].every(Boolean)) {
    return `${kind}-${name}${namespace ? `-${namespace}` : ""}`
  }

  throw new Error(
    `Bad manifest with name “${name}”, namespace “${namespace}” and kind “${manifest?.kind}”`
  )
}

function removeUselessForSnapshotsFields(manifest: Manifest): Manifest {
  const clone = JSON.parse(JSON.stringify(manifest))

  if (clone.metadata?.labels?.["helm.sh/chart"]) {
    clone.metadata.labels["helm.sh/chart"] = undefined
  }

  if (clone.spec?.template?.metadata?.labels?.["helm.sh/chart"]) {
    clone.spec.template.metadata.labels["helm.sh/chart"] = undefined
  }

  return clone
}

export async function renderDenoChart(chartData: string, chartPath: string) {
  await checkChartPath(chartPath)
  await fs.ensureDir(path.join(chartPath, "templates"))
  const templateFolderPath = path.join(chartPath, "templates")

  // deno-lint-ignore no-explicit-any
  const data = yaml.parseAll(chartData) as any[]

  const kubertaDataDocs = data.filter((doc) => doc.kind === "KubertaData")
  if (kubertaDataDocs.length === 0) {
    console.log(chartData)
    return
  }

  if (kubertaDataDocs.length > 1) {
    throw new Error("Invalid kuberta data: more then 1 KubertaData resource")
  }

  const kubertaData = kubertaDataDocs[0]

  const { release, values, jsTemplate } = parseKubertaData(kubertaData.spec)

  const jsTemplateTmpFilePath = await Deno.makeTempFile({
    prefix: "kuberta-chart-",
  })

  try {
    const file = await Deno.open(jsTemplateTmpFilePath, { write: true })
    await Deno.writeAll(file, new TextEncoder().encode(jsTemplate))
    Deno.close(file.rid)

    const denoResources = await import(jsTemplateTmpFilePath).then((chart) => {
      return chart.default({ release, values })
    })

    for await (const rawManifest of denoResources) {
      const manifest = removeUselessForSnapshotsFields(rawManifest)
      const templateName = getTemplateName(manifest)
      const templatePath = path.join(templateFolderPath, `${templateName}.yaml`)

      const updateTemplate = async () => {
        await fs.ensureDir(path.dirname(templatePath))
        await Deno.writeTextFile(templatePath, stringifyResource(manifest))
      }
      updateTemplate()
    }
  } finally {
    await Deno.remove(jsTemplateTmpFilePath)
    await Deno.remove(
      path.join(templateFolderPath, "kuberta-data.autogenerated.yaml")
    )
    await Deno.remove(path.join(chartPath, "deno.autogenerated.js"))
  }
}
